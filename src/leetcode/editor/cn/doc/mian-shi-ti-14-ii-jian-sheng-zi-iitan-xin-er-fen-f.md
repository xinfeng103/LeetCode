此题与 [面试题14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/) 主体等价，唯一不同在于本题目涉及 **“大数越界情况下的求余问题”** 。
建议先做上一道题，在此基础上再研究此题目的大数求余方法。

#### 解题思路：

- 设将长度为 *n* 的绳子切为 *a* 段：

*
n = n_1 + n_2 + ... + n_a
*

- 本题等价于求解：

![\max(n_1\timesn_2\times...\timesn_a) ](./p____max_n_1_times_n_2_times_..._times_n_a____.png) 

> 以下数学推导总体分为两步：① 当所有绳段长度相等时，乘积最大。② 最优的绳段长度为 *3* 。

##### 数学推导：

- 以下公式为“算术几何均值不等式” ，等号当且仅当 *n_1 = n_2 = ... = n_a* 时成立。

![\frac{n_1+n_2+...+n_a}{a}\geq\sqrt\[a\]{n_1n_2...n_a} ](./p____frac{n_1_+_n_2_+_..._+_n_a}{a}_geq_sqrt_a_{n_1_n_2_..._n_a}___.png) 

> **推论一：** 将绳子 **以相等的长度等分为多段** ，得到的乘积最大。

- 设将绳子按照 *x* 长度等分为 *a* 段，即 *n = ax* ，则乘积为 *x^a* 。观察以下公式，由于 *n* 为常数，因此当 ![x^{\frac{1}{x}} ](./p__x^{frac{1}{x}}_.png)  取最大值时， 乘积达到最大值。

![x^a=x^{\frac{n}{x}}=(x^{\frac{1}{x}})^n ](./p____x^a_=_x^{frac{n}{x}}_=__x^{frac{1}{x}}_^n___.png) 

- 根据分析，可将问题转化为求 ![y=x^{\frac{1}{x}} ](./p__y_=_x^{frac{1}{x}}_.png)  的极大值，因此对 *x* 求导数。

$$
\begin{aligned}
 \ln y & = \frac{1}{x} \ln x & \text{取对数} \\
 \frac{1}{y} \dot {y} & = \frac{1}{x^2} - \frac{1}{x^2} \ln x & \text{对 *x* 求导} \\
 & = \frac{1 - \ln x}{x^2} \\
 \dot {y} & = \frac{1 - \ln x}{x^2} x^{\frac{1}{x}} & \text{整理得}
\end{aligned}
$$

- 令 ![\dot{y}=0 ](./p__dot_{y}_=_0_.png)  ，则 ![1-\lnx=0 ](./p__1_-_ln_x_=_0_.png)  ，易得驻点为 ![x_0=e\approx2.7 ](./p__x_0_=_e_approx_2.7_.png)  ；根据以下公式，可知 *x_0* 为极大值点。

![\dot{y}\begin{cases}>0&,x\in\[-\infty,e)\\<0&,x\in(e,\infty\]\\\end{cases} ](./p____dot_{y}__begin{cases}_____0_&_,_x_in__-_infty,_e_______0_&_,_x_in__e,_infty____end{cases}___.png) 

- 由于切分长度 *x* 必须为整数，最接近 *e* 的整数为 *2* 或 *3* 。如下式所示，代入 *x = 2* 和 *x = 3* ，得出 *x = 3* 时，乘积达到最大。

![y(3)=3^{1/3}\approx1.44\\y(2)=2^{1/2}\approx1.41 ](./p____y_3__=_3^{1_3}_approx_1.44___y_2__=_2^{1_2}_approx_1.41___.png) 

- 口算对比方法：给两数字同时取 *6* 次方，再对比。

![\[y(3)\]^6=(3^{1/3})^6=9\\\[y(2)\]^6=(2^{1/2})^6=8 ](./p_____y_3__^6_=__3^{1_3}_^6_=_9____y_2__^6_=__2^{1_2}_^6_=_8___.png) 

> **推论二：** 尽可能将绳子以长度 *3* 等分为多段时，乘积最大。

##### 切分规则：

1. **最优：** *3* 。把绳子尽可能切为多个长度为 *3* 的片段，留下的最后一段绳子的长度可能为 *0,1,2* 三种情况。
2. **次优：** *2* 。若最后一段绳子长度为 *2* ；则保留，不再拆为 *1+1* 。
3. **最差：** *1* 。若最后一段绳子长度为 *1* ；则应把一份 *3 + 1* 替换为 *2 + 2*，因为 ![2\times2>3\times1 ](./p__2_times_2___3_times_1_.png) 。

##### 算法流程：

1. 当 ![n\leq3 ](./p__n_leq_3_.png)  时，按照规则应不切分，但由于题目要求必须剪成 *m>1* 段，因此必须剪出一段长度为 *1* 的绳子，即返回 *n - 1* 。
2. 当 *n>3* 时，求 *n* 除以 *3* 的 整数部分 *a* 和 余数部分 *b* （即 *n = 3a + b* ），并分为以下三种情况（设求余操作符号为 "![\odot ](./p__odot_.png) " ）：
    - 当 *b = 0* 时，直接返回 ![3^a\odot1000000007 ](./p__3^a_odot_1000000007_.png) ；
    - 当 *b = 1* 时，要将一个 *1 + 3* 转换为 *2+2*，因此返回 ![(3^{a-1}\times4)\odot1000000007 ](./p___3^{a-1}_times_4_odot_1000000007_.png) ；
    - 当 *b = 2* 时，返回 ![(3^a\times2)\odot1000000007 ](./p___3^a_times_2__odot_1000000007_.png) 。

![Picture1.png](https://pic.leetcode-cn.com/7ed7d54e40bdf83733923fb1667872ae2fa949d46c2cf49942e37b1925765ea3-Picture1.png)

##### 大数求余解法：

> **大数越界：** 当 *a* 增大时，最后返回的 *3^a* 大小以指数级别增长，可能超出 `int32` 甚至 `int64` 的取值范围，导致返回值错误。
> **大数求余问题：** 在仅使用 `int32` 类型存储的前提下，正确计算 *x^a* 对 *p* 求余（即 ![x^a\odotp ](./p__x^a_odot_p_.png)  ）的值。
> **解决方案：** *循环求余* 、 *快速幂求余* ，其中后者的时间复杂度更低，两种方法均基于以下求余运算规则推出：
> ![>(xy)\odotp=\[(x\odotp)(y\odotp)\]\odotp> ](./p_______xy__odot_p_=___x_odot_p__y_odot_p___odot_p_____.png) 

##### 1. 循环求余：

- 根据求余运算性质推出（∵ 本题中 *x<p*，∴ ![x\odotp=x ](./p__x_odot_p_=_x_.png)  ）：

![x^a\odotp=\[(x^{a-1}\odotp)(x\odotp)\]\odotp=\[(x^{a-1}\odotp)x\]\odotp ](./p____x^a_odot_p_=___x_^{a-1}_odot_p__x_odot_p___odot_p=__x_^{a-1}_odot_p_x__odot_p___.png) 

- **解析：** 利用此公式，可通过循环操作依次求 *x^1, x^2, ..., x^{a-1}, x^a* 对 *p* 的余数，保证每轮中间值 `rem` 都在 `int32` 取值范围中。封装方法代码如下所示。
- **时间复杂度 *O(N)* ：** 其中 *N=a* ，即循环的线性复杂度。

```python
# 求 (x^a) % p —— 循环求余法
def remainder(x, a, p):
    rem = 1
    for _ in range(a):
        rem = (rem * x) % p
    return rem
```

##### 2. 快速幂求余：

- 根据求余运算性质可推出：

![x^a\odotp=(x^2)^{a/2}\odotp=(x^2\odotp)^{a/2}\odotp ](./p____x^a_odot_p_=__x^2_^{a_2}_odot_p_=__x^2_odot_p_^{a___2}_odot_p___.png) 

- 当 *a* 为奇数时 *a/2* 不是整数，因此分为以下两种情况（ ''*//*'' 代表向下取整的除法）：

$$
{x^a \odot p = }
\begin{cases}
(x^2 \odot p)^{a // 2} \odot p &  \text{, *a* 为偶数} \\
{[(x \odot p)(x ^{a-1} \odot p)] \odot p = [x(x^2 \odot p)^{a//2}] \odot p} & \text{, *a* 为奇数} \\
\end{cases}
$$

- **解析：** 利用以上公式，可通过循环操作每次把指数 *a* 问题降低至指数 *a//2* 问题，只需循环 *log_2(N)* 次，因此可将复杂度降低至对数级别。封装方法代码如下所示。

```python
# 求 (x^a) % p —— 快速幂求余
def remainder(x, a, p):
    rem = 1
    while a > 0:
        if a % 2: rem = (rem * x) % p
        x = x ** 2 % p
        a //= 2
    return rem
```

- **帮助理解：** 根据下表， 初始状态 *rem=1*, *x=3*, *a=19*, *p=1000000007* ，最后会将 ![rem\times(x^a\odotp) ](./p__rem_times__x^a_odot_p__.png)  化为 ![rem\times(x^0\odotp)=rem\times1 ](./p__rem_times__x^0_odot_p__=_rem_times_1_.png)  的形式，即 *rem* 为余数答案。

| *n*  |                 ![rem\times(x^a\odotp) ](./p__rem_times__x^a_odot_p__.png)  | ![rem_n=rem_{n-1}\timesx_{n-1}\odotp ](./p__rem_n=rem_{n-1}_times_x_{n-1}_odot_p_.png)  |        ![x_n=x_{n-1}^2\odotp ](./p__x_n=x_{n-1}^2_odot_p_.png)  | *a_n=a_{n-1}//2* |
| ---- | -----------------------------------------: | ---------------------------------------: | -----------------------------: | :--------------: |
| *1*  |                ![1\times(3^{19}\odotp) ](./p__1_times__3^{19}_odot_p__.png)  |                                      *1* |                            *3* |       *19*       |
| *2*  |                 ![3\times(9^{9}\odotp) ](./p__3_times__9^{9}_odot_p__.png)  |                      ![3=1\times3\odotp ](./p__3=1times3odot_p_.png)  |                ![9=3^2\odotp ](./p__9=3^2_odot_p_.png)  |    *9=19//2*     |
| *3*  |               ![27\times(81^{4}\odotp) ](./p__27_times__81^{4}_odot_p__.png)  |                ![27=3\times9\odotp ](./p__27_=_3_times_9_odot_p_.png)  |                ![81=9^2\odotp ](./p__81=9^2odot_p_.png)  |     *4=9//2*     |
| *4*  |             ![27\times(6561^{2}\odotp) ](./p__27_times__6561^{2}_odot_p__.png)  |                                     *27* |            ![6561=81^2\odotp ](./p__6561=81^2_odot_p_.png)  |     *2=4//2*     |
| *5*  |         ![27\times(43046721^{1}\odotp) ](./p__27_times__43046721^{1}_odot_p__.png)  |                                     *27* |      ![43046721=6561^2\odotp ](./p__43046721=6561^2_odot_p_.png)  |     *1=2//2*     |
| *6*  | ![162261460\times(175880701^{0}\odotp) ](./p__162261460_times__175880701^{0}_odot_p__.png)  |   ![162261460=27\times43046721\odotp ](./p__162261460=27_times_43046721_odot_p_.png)  | ![175880701=43046721^2\odotp ](./p__175880701=43046721^2_odot_p_.png)  |     *0=1//2*     |

##### 复杂度分析：

> 以下为**二分求余法**的复杂度。

- **时间复杂度 ![O(\log_2N) ](./p__O_log_2_N__.png)  ：** 其中 *N=a* ，二分法为对数级别复杂度，每轮仅有求整、求余、次方运算。
  - [求整和求余运算](https://stackoverflow.com/questions/35189851/time-complexity-of-modulo-operator-in-python)：资料提到不超过机器数的整数可以看作是 *O(1)* ；
  - [幂运算](https://stackoverflow.com/questions/32418731/java-math-powa-b-time-complexity)：查阅资料，提到浮点取幂为 *O(1)* 。
- **空间复杂度 *O(1)* ：** 变量 `a, b, p, x, rem` 使用常数大小额外空间。

##### 代码：

> **Python 代码（第三栏）：** 由于语言特性，理论上 Python 中的变量取值范围由系统内存大小决定（无限大），因此在 Python 中其实不用考虑大数越界问题。
> **Java 代码：** 根据二分法计算原理，至少要保证变量 `x` 和 `rem` 可以正确存储 *1000000007^2* ，而 *2^{64} > 1000000007^2 > 2^{32}* ，因此我们选取 `long` 类型。

```python []
class Solution:
    def cuttingRope(self, n: int) -> int:
        if n <= 3: return n - 1
        a, b, p, x, rem = n // 3 - 1, n % 3, 1000000007, 3 , 1
        while a > 0:
            if a % 2: rem = (rem * x) % p
            x = x ** 2 % p
            a //= 2
        if b == 0: return (rem * 3) % p # = 3^(a+1) % p
        if b == 1: return (rem * 4) % p # = 3^a * 4 % p
        return (rem * 6) % p # = 3^(a+1) * 2  % p
```

```java []
class Solution {
    public int cuttingRope(int n) {
        if(n <= 3) return n - 1;
        int b = n % 3, p = 1000000007;
        long rem = 1, x = 3;
        for(int a = n / 3 - 1; a > 0; a /= 2) {
            if(a % 2 == 1) rem = (rem * x) % p;
            x = (x * x) % p;
        }
        if(b == 0) return (int)(rem * 3 % p);
        if(b == 1) return (int)(rem * 4 % p);
        return (int)(rem * 6 % p);
    }
}
```

```python []
# 由于语言特性，Python 可以不考虑大数越界问题
class Solution:
    def cuttingRope(self, n: int) -> int:
        if n <= 3: return n - 1
        a, b, p = n // 3, n % 3, 1000000007
        if b == 0: return 3 ** a % p
        if b == 1: return 3 ** (a - 1) * 4 % p
        return 3 ** a * 2 % p
```

> 数学推导需要一定的知识基础。下面分享一种基于贪心思想的思路，个人认为适合于时间有限情况下的快速解题。

##### 贪心思路：

> 设一绳子长度为 *n* ( *n>1* )，则其必可被切分为两段 *n=n_1+n_2* 。
> 根据经验推测，切分的两数字乘积往往原数字更大，即往往有 ![n_1\timesn_2>n_1+n_2=n ](./p__n_1_times_n_2___n_1_+_n_2_=_n_.png)  。
> - **例如绳子长度为 *6* ：**  ![6=3+3<3\times3=9 ](./p__6_=_3_+_3___3_times_3_=_9_.png)  ；
> - **也有少数反例，例如 *2* ：** ![2=1+1>1\times1=1 ](./p__2_=_1_+_1___1_times_1_=_1_.png)  。

- **推论一：** 合理的切分方案可以带来更大的乘积。

> 设一绳子长度为 *n* ( *n>1* )，**切分为两段** *n=n_1+n_2* ，**切分为三段** *n=n_1+n_2+n_3* 。
> 根据经验推测，**三段** 的乘积往往更大，即往往有 *n_1 n_2 n_3 > n_1 n_2* 。
> - **例如绳子长度为 *9* ：** 两段 *9=4+5* 和 三段 *9=3+3+3*，则有 ![4\times5<3\times3\times3 ](./p__4_times_5___3_times_3_times_3_.png)  。
> - **也有少数反例，例如 *6* ：** 两段 *6=3+3* 和 三段 *6=2+2+2*，则有 ![3\times3>2\times2\times2 ](./p__3_times_3___2_times_2_times_2_.png)  。

- **推论二：** 若切分方案合理，绳子段切分的越多，乘积越大。

> 总体上看，貌似长绳子切分为越多段乘积越大，但其实到某个长度分界点后，乘积到达最大值，就不应再切分了。
> **问题转化：** 是否有**优先级最高的长度** *x* 存在？若有，则应该尽可能把绳子以 *x* 长度切为多段，以获取最大乘积。

- **推论三：** 为使乘积最大，只有长度为 *2* 和 *3* 的绳子不应再切分，且 *3* 比 *2* 更优 *（详情见下表）* 。

| 绳子切分方案  | 乘积                                       |      结论                                        |
| ------------- | ------------------------------------------ | ----------------------------------------------- |
| *2 = 1 + 1*   | ![1\times1=1 ](./p__1_times_1_=_1_.png)                            | *2* 不应切分                                     |
| *3=1+2*       | ![1\times2=2 ](./p__1_times_2_=_2_.png)                            | *3* 不应切分                                     |
| *4=2+2=1+3*   | ![2\times2=4>1\times3=3 ](./p__2_times_2_=_4___1_times_3_=_3_.png)           | *4* 和 *2* 等价，且 *2+2* 比 *1+3* 更优           |
| *5=2+3=1+4*   | ![2\times3=6>1\times4=4 ](./p__2_times_3_=_6___1_times_4_=_4_.png)           | *5* 应切分为 *2+3*                               |
| *6=3+3=2+2+2* | ![3\times3=9>2\times2\times2=8 ](./p__3_times_3_=_9___2_times_2_times_2_=_8_.png)  | *6* 应切分为 *3+3* ，进而**推出 *3* 比 *2* 更优** |
| *>7*          | ...                                        | **长绳**（长度>7）可转化为多个**短绳**（长度1~6），因此肯定应切分 |